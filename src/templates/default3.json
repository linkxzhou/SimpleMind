{"data":{"text":"如何使用p5.js实现游戏","expand":true,"uid":"f9f92c06-bbfe-444b-a200-7537afd6391f","isActive":false},"children":[{"data":{"text":"p5.js 游戏开发基础概念与结构","note":"p5.js 是一个基于 JavaScript 的创意编程库，广泛用于游戏开发。它提供了丰富的绘图、动画和交互功能。游戏开发基础包括理解 p5.js 的核心函数（如 setup() 和 draw()）、游戏循环机制、坐标系系统以及基本的图形绘制。掌握这些概念是构建任何 p5.js 游戏的前提，它们为游戏逻辑、用户输入处理和视觉呈现奠定了基础。","nextSystemPrompt":"基于 p5.js 游戏开发基础，总结出核心函数、游戏循环、坐标系、图形绘制、颜色与样式、基本形状、文本渲染、画布操作等子知识点。","color":"#4A90E2","expand":true,"richText":false,"isActive":false,"uid":"25f11b3f-12a7-4f2a-9225-3b616dce0235"},"children":[{"data":{"text":"setup() 与 draw() 核心函数","note":"setup() 函数在程序开始时执行一次，用于初始化游戏设置，如创建画布、设置初始变量。draw() 函数每秒默认执行 60 次（可通过 frameRate() 调整），是游戏循环的核心，负责更新游戏状态和重绘画面。理解这两个函数的执行时机和用途对于控制游戏流程至关重要。","nextSystemPrompt":"基于核心函数，总结出初始化、循环控制、帧率管理、全局变量、函数调用顺序等子知识点。","color":"#5DADE2","expand":true,"richText":false,"isActive":false,"uid":"ed7c5d49-7ecd-47a1-9f5c-6f0a108e6790"},"children":[]},{"data":{"text":"p5.js 游戏循环机制","note":"游戏循环是驱动游戏运行的核心，在 p5.js 中主要由 draw() 函数实现。每一帧中，循环会处理用户输入、更新游戏逻辑（如角色移动、碰撞检测）、然后渲染画面。合理管理循环效率（避免过度计算）和使用帧率控制是保证游戏流畅性的关键。","nextSystemPrompt":"基于游戏循环机制，总结出状态更新、画面渲染、输入处理、性能优化、帧率同步等子知识点。","color":"#5499C7","expand":true,"richText":false,"isActive":false,"uid":"6143c132-4f2e-4d76-a306-19a7f9afb41a"},"children":[]},{"data":{"text":"坐标系与变换","note":"p5.js 使用二维笛卡尔坐标系，原点 (0,0) 默认在画布左上角。开发者可以使用 translate(), rotate(), scale() 等函数进行坐标系变换，这对于实现复杂的动画和相对定位非常重要。理解坐标系统是精确控制游戏元素位置的基础。","nextSystemPrompt":"基于坐标系与变换，总结出原点设置、平移、旋转、缩放、矩阵堆栈、相对坐标等子知识点。","color":"#2980B9","expand":true,"richText":false,"isActive":false,"uid":"f3e3d312-781e-4fde-a3ff-fd06ddaee797"},"children":[]},{"data":{"text":"基本图形绘制与样式","note":"p5.js 提供了简单的函数来绘制基本图形，如 ellipse()（椭圆）、rect()（矩形）、line()（线条）。可以通过 fill() 和 stroke() 设置填充和描边颜色，使用 strokeWeight() 设置线条粗细。这些是构建游戏视觉元素（如角色、障碍物）的基本工具。","nextSystemPrompt":"基于基本图形绘制，总结出形状函数、颜色模型、透明度、样式继承、自定义图形等子知识点。","color":"#2471A3","expand":true,"richText":false,"isActive":false,"uid":"e6cc9825-8d5f-41fa-b753-08603a00295b"},"children":[]},{"data":{"text":"颜色模型与填充","note":"p5.js 支持 RGB、HSB 等多种颜色模型。color() 函数用于定义颜色，fill() 用于设置形状内部颜色，stroke() 用于设置边框颜色。alpha 通道支持透明度效果。灵活运用颜色可以增强游戏的视觉效果和用户体验。","nextSystemPrompt":"基于颜色模型与填充，总结出 RGB/HSB 值、颜色字符串、透明度应用、渐变填充、颜色动态变化等子知识点。","color":"#1F618D","expand":true,"richText":false,"isActive":false,"uid":"5174c772-58a8-4f8e-a4d0-b995c41a13e6"},"children":[]},{"data":{"text":"文本渲染与字体","note":"使用 text() 函数可以在画布上显示文本，常用于显示分数、生命值或游戏标题。可以设置文本大小 textSize()、对齐方式 textAlign() 和字体 textFont()。加载自定义字体（如 .ttf 或 .otf 文件）可以提升游戏的美观度。","nextSystemPrompt":"基于文本渲染与字体，总结出文本属性、字体加载、文本测量、动态文本更新、多语言支持等子知识点。","color":"#1A5276","expand":true,"richText":false,"isActive":false,"uid":"6a38fa48-489a-4eba-806e-6657bc5d0785"},"children":[]},{"data":{"text":"画布创建与尺寸设置","note":"createCanvas() 函数用于在 HTML 页面中创建一块绘图区域（画布）。设置合适的宽度和高度是关键，可以响应式地适应不同屏幕尺寸（使用 windowWidth 和 windowHeight）。画布是游戏呈现的唯一区域。","nextSystemPrompt":"基于画布创建与尺寸，总结出像素密度、全屏模式、多画布管理、画布样式、响应式设计等子知识点。","color":"#154360","expand":true,"richText":false,"isActive":false,"uid":"d3b0ad15-ecde-43fb-818c-806077e80c71"},"children":[]},{"data":{"text":"基本形状：矩形、圆形、线条","note":"rect() 绘制矩形，可指定位置、宽高及圆角。ellipse() 绘制椭圆或圆形，由中心点坐标和轴半径定义。line() 绘制直线，连接两个点。这些是构建游戏世界中最基础的几何元素。","nextSystemPrompt":"基于基本形状，总结出参数含义、绘制模式（CENTER/CORNER）、形状组合、边界计算、自定义顶点等子知识点。","color":"#1B4F72","expand":true,"richText":false,"isActive":false,"uid":"6da8025c-f861-4292-8b94-5dfc31e64ee0"},"children":[]},{"data":{"text":"图像加载与显示","note":"loadImage() 函数用于异步加载图片资源（如角色精灵、背景图），然后在 draw() 中使用 image() 函数显示。管理图片预加载（在 setup() 中完成）对于避免渲染时闪烁或延迟非常重要。","nextSystemPrompt":"基于图像加载与显示，总结出图片格式支持、缩放显示、图像切片、预加载队列、动态图像切换等子知识点。","color":"#2874A6","expand":true,"richText":false,"isActive":false,"uid":"d249a599-8f29-494d-addf-7d7836b7cd65"},"children":[]},{"data":{"text":"资源管理与预加载","note":"游戏通常需要加载图片、声音、字体等资源。p5.js 的 preload() 函数确保所有资源在 setup() 和 draw() 执行前加载完毕，防止运行时错误。合理管理资源生命周期是游戏稳定性的基础。","nextSystemPrompt":"基于资源管理与预加载，总结出 preload 函数、加载回调、错误处理、资源缓存、异步加载等子知识点。","color":"#2E86C1","expand":true,"richText":false,"isActive":false,"uid":"dfbdb28c-0999-48bf-baf2-87cd9f97c4f3"},"children":[]}]},{"data":{"text":"游戏逻辑与交互实现","note":"游戏逻辑是游戏的核心，包括角色控制、物体运动、碰撞检测、胜负条件判断等。交互实现则关乎玩家如何与游戏世界沟通，主要处理键盘、鼠标等输入事件。在 p5.js 中，通过变量存储游戏状态，在 draw() 循环中更新逻辑，并利用内置函数（如 keyIsPressed, mousePressed）捕获用户输入，从而创造出动态且响应迅速的游戏体验。","nextSystemPrompt":"基于游戏逻辑与交互，总结出变量与状态、角色移动、碰撞系统、输入处理、游戏规则、计时器、动画过渡、物理模拟、AI行为、场景管理子知识点。","color":"#E74C3C","expand":true,"richText":false,"isActive":false,"uid":"06c08852-1919-47e8-aab4-48ed168dd5fe"},"children":[{"data":{"text":"变量与游戏状态管理","note":"使用 JavaScript 变量（如 let, const）来存储游戏中的动态数据，如玩家位置、分数、生命值、游戏是否进行中（Game State）。良好的状态管理（例如使用枚举或状态机）使代码更清晰，易于维护和扩展。","nextSystemPrompt":"基于变量与状态管理，总结出数据类型、作用域、状态常量、状态切换逻辑、全局状态对象等子知识点。","color":"#EC7063","expand":true,"richText":false,"isActive":false,"uid":"c1c98e87-1df5-48ca-85fc-7da75684ab28"},"children":[]},{"data":{"text":"精灵（角色）移动与控制","note":"通过改变表示精灵（游戏角色）位置的变量（如 x, y 坐标），并在每一帧重新绘制来实现移动。移动模式包括键盘控制（根据按键更新坐标）、自动移动（如敌人AI）以及基于物理的速度和加速度模拟。","nextSystemPrompt":"基于精灵移动与控制，总结出坐标更新、速度加速度、键盘映射、平滑移动、边界限制等子知识点。","color":"#F1948A","expand":true,"richText":false,"isActive":false,"uid":"744a615a-a2ac-4526-8b0e-d6abd1064bb8"},"children":[]},{"data":{"text":"碰撞检测算法","note":"碰撞检测是判断游戏对象是否相交的关键算法。简单碰撞包括矩形碰撞（比较边界框）和圆形碰撞（比较圆心距离与半径和）。复杂的像素级碰撞可能需要更多计算。高效的碰撞检测是游戏性能的重要部分。","nextSystemPrompt":"基于碰撞检测算法，总结出矩形碰撞、圆形碰撞、点与形状碰撞、碰撞响应、优化策略等子知识点。","color":"#F5B7B1","expand":true,"richText":false,"isActive":false,"uid":"91c1ced2-48a0-4f01-89d1-80324c3efe37"},"children":[]},{"data":{"text":"键盘与鼠标输入处理","note":"p5.js 提供了 keyCode, keyIsPressed, mouseX, mouseY, mouseIsPressed 等系统变量来获取输入状态。还可以使用 keyPressed(), mousePressed() 等事件函数来响应特定的按键或点击动作，实现角色跳跃、射击等交互。","nextSystemPrompt":"基于键盘鼠标输入处理，总结出键位映射、持续按压与单击、鼠标位置跟踪、滚轮事件、输入消抖等子知识点。","color":"#D98880","expand":true,"richText":false,"isActive":false,"uid":"6998964c-1d96-4d18-b41c-53db9c91ab11"},"children":[]},{"data":{"text":"游戏规则与胜负条件","note":"定义清晰的游戏规则，如得分条件（收集物品）、失败条件（生命值为零或碰到敌人）和胜利条件（到达终点）。在游戏循环中持续检查这些条件，并触发相应的游戏状态改变（如结束游戏、进入下一关）。","nextSystemPrompt":"基于游戏规则与胜负条件，总结出条件判断、分数系统、生命值管理、关卡设计、游戏结束逻辑等子知识点。","color":"#CD6155","expand":true,"richText":false,"isActive":false,"uid":"49bf921b-cbe9-4aa4-874d-11f6efb4c96a"},"children":[]},{"data":{"text":"计时器与帧数控制","note":"利用 frameCount 变量（记录从开始绘制的总帧数）或 millis() 函数（返回程序运行毫秒数）来创建计时器。用于实现技能冷却、道具出现间隔、动画延迟等与时间相关的游戏逻辑。控制帧率（frameRate）可以优化性能。","nextSystemPrompt":"基于计时器与帧数控制，总结出定时事件、延迟执行、帧数计算、性能监控、时间增量等子知识点。","color":"#C0392B","expand":true,"richText":false,"isActive":false,"uid":"4ff22313-f3cd-4c52-b36b-8e16f0c7f3b5"},"children":[]},{"data":{"text":"动画与过渡效果","note":"通过连续改变物体的属性（位置、大小、颜色、旋转角度）来创建动画。可以使用线性插值（lerp）实现平滑过渡。帧动画（Sprite Animation）则是通过连续播放一系列图像来实现复杂的角色动作。","nextSystemPrompt":"基于动画与过渡效果，总结出属性动画、插值计算、精灵图序列、动画帧率、缓动函数等子知识点。","color":"#A93226","expand":true,"richText":false,"isActive":false,"uid":"07a261b7-8760-4198-8ac7-6294dcd044e4"},"children":[]},{"data":{"text":"简单物理模拟（重力、反弹）","note":"为游戏增加真实性，可以模拟简单的物理学原理。例如，为物体添加重力加速度（持续增加向下的速度），当物体碰到地面时反转速度实现反弹效果。这常用于平台跳跃类游戏。","nextSystemPrompt":"基于简单物理模拟，总结出重力加速度、速度矢量、反弹系数、摩擦力模拟、运动学公式等子知识点。","color":"#922B21","expand":true,"richText":false,"isActive":false,"uid":"79b788c4-cd9f-4c96-ac61-9e38cf288ae0"},"children":[]},{"data":{"text":"敌人AI与行为模式","note":"为非玩家角色（NPC/敌人）设计人工智能。简单的AI包括巡逻（在固定路径移动）、追逐（向玩家移动）、逃跑等行为模式。通过条件判断（如距离检测）来切换不同的行为状态。","nextSystemPrompt":"基于敌人AI与行为模式，总结出状态机、寻路算法、感知范围、行为优先级、随机行为等子知识点。","color":"#7B241C","expand":true,"richText":false,"isActive":false,"uid":"e69a103a-d7e7-4148-8af5-a1a3c6194555"},"children":[]},{"data":{"text":"场景管理与切换","note":"复杂的游戏可能有多个场景，如开始菜单、游戏主界面、结束画面。使用一个全局变量（如 currentScene）来标识当前场景，并在 draw() 函数中根据该变量渲染不同的内容。实现场景间的平滑切换。","nextSystemPrompt":"基于场景管理与切换，总结出场景枚举、场景初始化、场景渲染函数、切换过渡效果、数据传递等子知识点。","color":"#641E16","expand":true,"richText":false,"isActive":false,"uid":"d0c5c166-bda4-4371-bb8f-d40d1c8ff5db"},"children":[]}]},{"data":{"text":"p5.js 高级游戏开发技巧","note":"在掌握了基础之后，高级技巧可以大幅提升游戏的质量和复杂度。这包括使用面向对象编程（OOP）来更好地组织代码、创建复杂的精灵动画、集成声音效果和背景音乐、使用粒子系统制造爆炸等特效，以及进行性能优化以确保游戏在各种设备上都能流畅运行。这些技巧是开发出专业级 p5.js 游戏的关键。","nextSystemPrompt":"基于高级游戏开发技巧，总结出面向对象编程、精灵动画系统、声音集成、粒子特效、性能优化、数组与对象管理、高级碰撞、随机生成、本地存储、第三方库集成子知识点。","color":"#27AE60","expand":true,"richText":false,"isActive":false,"uid":"6e33dc94-a61f-4c1d-9afe-62c6d463329c"},"children":[{"data":{"text":"面向对象编程（OOP）应用","note":"使用 JavaScript 的类（Class）语法为游戏中的实体（如玩家、敌人、子弹）创建蓝图。OOP 将数据（属性）和功能（方法）封装在一起，使代码更模块化、可重用和易于管理，特别适用于有大量相似对象的游戏。","nextSystemPrompt":"基于面向对象编程，总结出类定义、构造函数、方法、继承、多态、对象数组管理等子知识点。","color":"#58D68D","expand":true,"richText":false,"isActive":false,"uid":"5406a5b4-08e0-479d-be9f-547e897957f9"},"children":[]},{"data":{"text":"精灵图（Sprite）与帧动画","note":"精灵图是一张包含动画所有帧的图像序列。通过在不同的时间显示精灵图的不同部分（使用 image() 函数的 sx, sy, sWidth, sHeight 参数），可以创造出流畅的角色动画。需要管理当前帧索引和动画播放速度。","nextSystemPrompt":"基于精灵图与帧动画，总结出精灵表布局、帧索引计算、动画循环、不同动作切换、动画类封装等子知识点。","color":"#52BE80","expand":true,"richText":false,"isActive":false,"uid":"b8810ae0-6248-44bf-be9a-df536917a623"},"children":[]},{"data":{"text":"声音效果与背景音乐","note":"p5.js 的 p5.sound 库提供了加载和播放音频的功能。使用 loadSound() 加载音效和音乐，play() 进行播放。可以控制音量、速率、循环等属性。合理使用声音能极大增强游戏的沉浸感。","nextSystemPrompt":"基于声音效果与背景音乐，总结出音效加载、播放控制、音量调节、空间音效、音频可视化等子知识点。","color":"#48C9B0","expand":true,"richText":false,"isActive":false,"uid":"36772043-fabe-4b80-b363-17db53ffd40d"},"children":[]},{"data":{"text":"粒子系统特效","note":"粒子系统用于模拟自然现象（火、烟、雨、爆炸）。由大量微小的粒子组成，每个粒子有位置、速度、生命周期等属性。在每一帧更新并绘制所有粒子，创建出复杂的动态视觉效果。","nextSystemPrompt":"基于粒子系统特效，总结出粒子类设计、发射器、粒子行为、渲染优化、生命周期管理等子知识点。","color":"#45B39D","expand":true,"richText":false,"isActive":false,"uid":"e7a6d09a-3934-45d0-8b32-737cf85e0245"},"children":[]},{"data":{"text":"性能优化与调试","note":"确保游戏流畅运行的关键。优化方法包括：减少不必要的计算、使用合适的帧率、优化碰撞检测（如空间分割）、避免内存泄漏。使用浏览器开发者工具（Console, Performance）进行调试和性能分析。","nextSystemPrompt":"基于性能优化与调试，总结出帧率监控、计算复杂度、内存管理、控制台调试、性能分析工具等子知识点。","color":"#52BE80","expand":true,"richText":false,"isActive":false,"uid":"d54a67db-cee9-4961-824f-7224d5fc6155"},"children":[]},{"data":{"text":"数组与对象集合管理","note":"游戏中的多个对象（如敌人数组、子弹数组）通常存储在数组中。需要高效地遍历数组来更新和渲染每个对象，同时及时删除不再需要的对象（如飞出屏幕的子弹）以释放资源。","nextSystemPrompt":"基于数组与对象集合管理，总结出数组遍历、增删改查、对象池模式、高效检索、迭代器使用等子知识点。","color":"#58D68D","expand":true,"richText":false,"isActive":false,"uid":"06f1987b-bcce-474c-a1ab-977000e718ce"},"children":[]},{"data":{"text":"高级碰撞检测（像素级、射线投射）","note":" beyond 简单的矩形/圆形碰撞。像素级碰撞比较两个精灵不透明像素的重叠，更精确但计算成本高。射线投射用于检测视线或射击命中，通过发射一条线并检查与物体的交点。","nextSystemPrompt":"基于高级碰撞检测，总结出像素数据访问、颜色透明度判断、射线方程、交点计算、性能权衡等子知识点。","color":"#45B39D","expand":true,"richText":false,"isActive":false,"uid":"d43daf6d-fb29-41bc-8a97-920c569e503e"},"children":[]},{"data":{"text":"程序化内容生成","note":"使用算法（如随机数、噪声函数）在游戏中动态生成内容，如随机地图、关卡、敌人布局。这可以增加游戏的可玩性和重玩价值。p5.js 的 random() 和 noise() 函数是常用工具。","nextSystemPrompt":"基于程序化内容生成，总结出随机数种子、柏林噪声、生成算法设计、可控随机性、动态难度调整等子知识点。","color":"#48C9B0","expand":true,"richText":false,"isActive":false,"uid":"8ef07a98-0b37-4e93-8cf3-5eac7c1719ba"},"children":[]},{"data":{"text":"本地存储与游戏存档","note":"利用浏览器的 localStorage API 将游戏数据（如最高分、解锁关卡）保存在用户的本地设备上。实现游戏的存档和读档功能，提升用户体验。","nextSystemPrompt":"基于本地存储与游戏存档，总结出 localStorage 使用、数据序列化（JSON）、存档点设计、数据加密、存储限制等子知识点。","color":"#52BE80","expand":true,"richText":false,"isActive":false,"uid":"88710747-62a0-4706-8f28-d02ab173f8ce"},"children":[]},{"data":{"text":"集成第三方库与插件","note":"p5.js 可以与其他 JavaScript 库结合以扩展功能。例如，使用 p5.play 简化精灵和动画管理，使用 Matter.js 集成更复杂的 2D 物理引擎，或者用 Chart.js 在游戏中显示数据图表。","nextSystemPrompt":"基于集成第三方库，总结出库的引入、API 调用、库与 p5 协同工作、常见游戏库介绍、兼容性处理等子知识点。","color":"#58D68D","expand":true,"richText":false,"isActive":false,"uid":"a540f765-5f26-41ab-bfd9-92fde3cc454d"},"children":[]}]},{"data":{"text":"游戏项目结构与发布部署","note":"一个组织良好的项目结构是可持续开发的基础。这包括如何规划文件夹（用于存放图片、声音、代码）、如何模块化代码（将不同功能的代码分离到多个 .js 文件中）。最后，将完成的游戏部署到网上，让其他人可以访问和游玩，通常涉及使用 GitHub Pages 或其他静态网站托管服务。","nextSystemPrompt":"基于游戏项目结构与发布，总结出项目目录规划、代码模块化、HTML文件配置、版本控制、静态部署、跨平台测试、文档编写子知识点。","color":"#8E44AD","expand":true,"richText":false,"isActive":false,"uid":"6f165e85-1751-4986-b113-76501d036747"},"children":[{"data":{"text":"项目目录结构与资源组织","note":"创建清晰的文件夹结构来组织项目文件，例如：`js/` 存放 JavaScript 代码文件，`assets/images/` 存放图片，`assets/sounds/` 存放音频，`index.html` 为主页面。良好的结构便于团队协作和后期维护。","nextSystemPrompt":"基于项目目录结构，总结出文件夹命名规范、资源路径引用、模块化分离、配置文件管理等子知识点。","color":"#BB8FCE","expand":true,"richText":false,"isActive":false,"uid":"721ac8e5-3400-4011-a5b5-682660cf6e91"},"children":[]},{"data":{"text":"代码模块化与分离","note":"将庞大的游戏代码按功能拆分成多个模块（不同的 .js 文件）。例如，将玩家类、敌人类、工具函数分别放在不同的文件中。在 index.html 中用 <script> 标签按顺序引入。这提高了代码的可读性和可维护性。","nextSystemPrompt":"基于代码模块化与分离，总结出文件拆分原则、全局命名空间管理、模块依赖关系、ES6 模块化等子知识点。","color":"#AF7AC5","expand":true,"richText":false,"isActive":false,"uid":"2e205191-1f51-4ca7-890d-940438454018"},"children":[]},{"data":{"text":"HTML 文件配置与画布集成","note":"index.html 文件是游戏的入口。需要正确引入 p5.js 库和自定义的 JavaScript 文件。可以设置页面的标题、样式，并确保 createCanvas() 创建的画布能够正确地嵌入到页面布局中。","nextSystemPrompt":"基于HTML文件配置，总结出 script 标签顺序、CSS 样式设置、画布居中、元标签设置、移动端适配等子知识点。","color":"#A569BD","expand":true,"richText":false,"isActive":false,"uid":"10212e6b-ca10-49f5-8ecb-9206f460bcda"},"children":[]},{"data":{"text":"版本控制（Git）基础","note":"使用 Git 进行版本控制是现代软件开发的标准实践。初始化 Git 仓库，通过 commit 保存项目进度，创建分支进行新功能开发。便于回滚错误、追踪更改历史和团队协作。","nextSystemPrompt":"基于版本控制基础，总结出仓库初始化、提交代码、分支管理、.gitignore 文件、远程仓库等子知识点。","color":"#9B59B6","expand":true,"richText":false,"isActive":false,"uid":"71393bb4-08e8-41ba-80b5-5a658e8b2eb3"},"children":[]},{"data":{"text":"使用 GitHub Pages 免费部署","note":"GitHub Pages 允许将静态网站（如 p5.js 游戏）直接从 GitHub 仓库部署到互联网。只需将代码推送到特定分支（如 gh-pages 或 main），即可通过一个公开 URL 访问游戏。这是最简单的部署方式之一。","nextSystemPrompt":"基于GitHub Pages部署，总结出仓库设置、分支选择、访问链接、自定义域名、HTTPS支持等子知识点。","color":"#8E44AD","expand":true,"richText":false,"isActive":false,"uid":"e0414f8a-6bb2-4783-8d10-80e3ccbe0b90"},"children":[]},{"data":{"text":"其他静态网站托管服务","note":"除了 GitHub Pages，还有其他平台可以部署 p5.js 游戏，如 Netlify, Vercel, Firebase Hosting。它们通常提供更丰富的功能，如持续自动部署、自定义域名、环境变量等。","nextSystemPrompt":"基于其他静态网站托管，总结出平台选择、部署流程、域名绑定、性能对比、免费额度等子知识点。","color":"#7D3C98","expand":true,"richText":false,"isActive":false,"uid":"4fa586f9-c1ab-4a91-a21b-5d3ca7ef515c"},"children":[]},{"data":{"text":"跨浏览器与设备测试","note":"在发布前，必须在不同的浏览器（Chrome, Firefox, Safari, Edge）和设备（桌面、手机、平板）上测试游戏，确保功能正常、布局正确、性能达标。响应式设计对于移动端体验尤为重要。","nextSystemPrompt":"基于跨浏览器设备测试，总结出浏览器兼容性、移动端触摸事件、屏幕尺寸适配、性能测试、用户体验评估等子知识点。","color":"#6C3483","expand":true,"richText":false,"isActive":false,"uid":"511f2f60-6226-4e4c-a1af-f99472dcc6a4"},"children":[]},{"data":{"text":"游戏打包与资源优化","note":"发布前对游戏资源进行优化，如压缩图片和音频文件以减少加载时间。对于更复杂的项目，可以考虑使用构建工具（如 Webpack）将代码和资源打包优化，但简单 p5.js 游戏通常不需要。","nextSystemPrompt":"基于游戏打包与资源优化，总结出图片压缩、音频格式选择、代码压缩、构建工具介绍、加载速度优化等子知识点。","color":"#5B2C6F","expand":true,"richText":false,"isActive":false,"uid":"2a0b9615-ed13-48e5-ab78-18d6d9e2935f"},"children":[]},{"data":{"text":"编写游戏说明文档","note":"为游戏编写清晰的说明文档，包括游戏玩法介绍、操作指南、功能特性等。可以写在项目仓库的 README.md 文件中，或者直接放在游戏页面内。好的文档能帮助玩家快速上手。","nextSystemPrompt":"基于编写游戏说明文档，总结出 README 结构、玩法描述、截图添加、控制说明、更新日志等子知识点。","color":"#4A235A","expand":true,"richText":false,"isActive":false,"uid":"5ad84fa0-cc28-4239-88b1-960db8b23075"},"children":[]},{"data":{"text":"分享与收集反馈","note":"将游戏部署后，通过社交媒体、游戏论坛或向朋友分享链接来推广你的游戏。积极收集玩家的反馈，了解游戏的优点和不足，为后续的更新和优化提供方向。","nextSystemPrompt":"基于分享与收集反馈，总结出分享渠道、反馈收集方法、数据分析、社区互动、迭代更新计划等子知识点。","color":"#76448A","expand":true,"richText":false,"isActive":false,"uid":"dbaec2d0-b003-4c48-be1b-07a84582ca2c"},"children":[]}]},{"data":{"text":"常见游戏类型与 p5.js 实现案例","note":"了解不同类型的游戏及其在 p5.js 中的典型实现方式，可以帮助开发者快速选择技术方案。常见的类型包括平台跳跃游戏（如超级马里奥）、射击游戏、益智游戏（如俄罗斯方块）、贪吃蛇等经典游戏。分析这些案例的核心机制和代码结构，是学习游戏开发非常有效的途径。","nextSystemPrompt":"基于常见游戏类型与实现案例，总结出平台跳跃、射击游戏、益智游戏、经典复刻、物理游戏、角色扮演、无限跑酷、棋牌游戏、文字冒险、模拟经营子知识点。","color":"#F39C12","expand":true,"richText":false,"isActive":false,"uid":"716943cd-0ac5-411b-9afc-a47ce6206fbb"},"children":[{"data":{"text":"平台跳跃游戏实现","note":"典型代表如超级马里奥。核心机制包括角色左右移动、跳跃（受重力影响）、与平台（地面）的碰撞检测、收集物品、击败敌人。需要精细的碰撞处理（特别是顶部、侧面、底部的碰撞响应）。","nextSystemPrompt":"基于平台跳跃游戏实现，总结出重力模拟、跳跃力学、平台生成、敌人AI、关卡设计、摄像机跟踪等子知识点。","color":"#F7DC6F","expand":true,"richText":false,"isActive":false,"uid":"b8751764-cf4f-41bc-a79e-dd4c730e85c4"},"children":[]},{"data":{"text":"射击游戏（Shooter）实现","note":"包括固定射击（如太空侵略者）和自由移动射击。核心是控制主角发射子弹，子弹与敌人的碰撞检测，敌人的生成和移动模式，以及分数系统。可能涉及双摇杆控制（移动和瞄准分离）。","nextSystemPrompt":"基于射击游戏实现，总结出子弹管理系统、敌人生成波次、碰撞检测优化、武器系统、爆炸效果等子知识点。","color":"#F4D03F","expand":true,"richText":false,"isActive":false,"uid":"2eaeaeec-c43b-42ad-ae71-76852d82af1e"},"children":[]},{"data":{"text":"益智游戏（Puzzle）实现","note":"如俄罗斯方块、华容道、消消乐。核心是游戏规则逻辑的实现，如俄罗斯方块的形状旋转、消行判断；消消乐的匹配算法。通常网格（Grid）系统是基础，需要高效的逻辑判断。","nextSystemPrompt":"基于益智游戏实现，总结出网格数据结构、形状旋转算法、匹配检测、自动下落、下一步预览等子知识点。","color":"#F1C40F","expand":true,"richText":false,"isActive":false,"uid":"5748ae11-20d9-4d49-952f-87231559be48"},"children":[]},{"data":{"text":"经典游戏复刻（贪吃蛇）","note":"贪吃蛇是入门经典。核心是蛇身由一个移动的线段序列表示，通过键盘控制方向，吃到食物后身体变长，碰到自身或边界游戏结束。涉及数组管理（存储蛇身坐标）和网格移动。","nextSystemPrompt":"基于经典游戏复刻，总结出蛇身数组管理、移动算法、食物随机生成、自碰撞检测、游戏速度递增等子知识点。","color":"#D4AC0D","expand":true,"richText":false,"isActive":false,"uid":"8c942c9e-7953-4e2e-951d-a482923558d9"},"children":[]},{"data":{"text":"物理模拟游戏（弹球、愤怒的小鸟风）","note":"利用简单的物理引擎（可自实现或集成 Matter.js）模拟真实物理。如弹球游戏中的碰撞和反弹，或像愤怒的小鸟那样的抛射物轨迹计算。重点是力的模拟和碰撞响应。","nextSystemPrompt":"基于物理模拟游戏，总结出刚体属性、力与力矩、碰撞回调、轨迹预测、物理引擎集成等子知识点。","color":"#B7950B","expand":true,"richText":false,"isActive":false,"uid":"6794dc29-e50c-4878-a458-a10c162cbbd8"},"children":[]},{"data":{"text":"角色扮演游戏（RPG）元素","note":"即使是简单 RPG，也可能包含角色属性（生命、攻击力）、背包系统、对话树、任务系统。在 p5.js 中实现，需要复杂的状态管理和界面切换（如从地图切换到背包界面）。","nextSystemPrompt":"基于角色扮演游戏元素，总结出属性系统、物品数据库、对话系统、任务逻辑、地图切换等子知识点。","color":"#9C640C","expand":true,"richText":false,"isActive":false,"uid":"bfbb5217-765a-475d-8250-976c87313ee2"},"children":[]},{"data":{"text":"无限跑酷游戏","note":"如 Temple Run 的 2D 简化版。角色自动向前跑动，玩家控制跳跃或下滑来躲避障碍。场景（背景、障碍物）循环生成，造成无限延伸的错觉。需要对象池技术来高效管理不断生成的障碍物。","nextSystemPrompt":"基于无限跑酷游戏，总结出自动滚动、程序化障碍生成、对象池模式、速度随时间增加、分数计算等子知识点。","color":"#7E5109","expand":true,"richText":false,"isActive":false,"uid":"f8a36b0c-f426-4d41-b4b6-45251d0d3751"},"children":[]},{"data":{"text":"棋牌类游戏（井字棋、扑克）","note":"实现棋盘/牌桌的绘制，处理玩家的回合制逻辑，以及简单的AI（如井字棋的电脑对手）。核心是二维数组表示棋盘状态，并实现胜负判断算法。","nextSystemPrompt":"基于棋牌类游戏，总结出棋盘状态表示、胜负判定算法、回合制逻辑、简单AI（极小化极大算法）、鼠标点击交互等子知识点。","color":"#F7DC6F","expand":true,"richText":false,"isActive":false,"uid":"c55ca014-8268-483d-8191-2ffc86e72892"},"children":[]},{"data":{"text":"文字冒险游戏","note":"侧重于叙事和选择。在 p5.js 中可以通过显示文本、选项按钮和背景图片来实现。核心是管理游戏的故事流程和玩家选择所带来的分支，通常使用状态机或脚本系统。","nextSystemPrompt":"基于文字冒险游戏，总结出故事脚本结构、选项分支管理、状态保存与读取、文本显示效果、背景音乐氛围等子知识点。","color":"#F4D03F","expand":true,"richText":false,"isActive":false,"uid":"83a330e3-bb92-4f95-b0a4-aef8d8e71eb7"},"children":[]},{"data":{"text":"简单模拟经营游戏","note":"如模拟咖啡馆。核心是资源管理（金钱、食材）、时间流逝、顾客生成与服务。需要实现升级系统（购买更好的设备）和数值平衡，使游戏具有成长性和挑战性。","nextSystemPrompt":"基于简单模拟经营游戏，总结出资源变量、时间管理器、顾客AI、升级系统、数值平衡设计等子知识点。","color":"#F1C40F","expand":true,"richText":false,"isActive":false,"uid":"398afada-d742-4e6b-b9da-923bd3d0a385"},"children":[]}]},{"data":{"text":"p5.js 游戏调试与错误处理","note":"开发过程中难免遇到 bug（错误）。掌握有效的调试技巧至关重要。这包括使用浏览器控制台（Console）打印日志（console.log）来追踪变量值和程序流程，使用调试器（Debugger）设置断点进行逐行检查，以及编写健壮的代码来处理可能出现的异常情况，确保游戏不会因为意外错误而完全崩溃。","nextSystemPrompt":"基于游戏调试与错误处理，总结出控制台日志、断点调试、常见错误类型、异常处理、代码审查、测试用例、性能分析、用户体验调试子知识点。","color":"#16A085","expand":true,"richText":false,"isActive":false,"uid":"79a6799b-ebb9-4d62-86df-5d221862e4cb"},"children":[{"data":{"text":"浏览器控制台（Console）使用","note":"浏览器开发者工具中的 Console 是首要调试工具。使用 console.log() 输出变量值、函数调用信息。console.error() 和 console.warn() 用于提示错误和警告。帮助开发者理解代码的执行过程。","nextSystemPrompt":"基于控制台使用，总结出日志输出、变量监视、表格显示、条件断点、控制台命令等子知识点。","color":"#73C6B6","expand":true,"richText":false,"isActive":false,"uid":"95285421-f40d-4bb8-8210-b529ed5a3c1e"},"children":[]},{"data":{"text":"设置断点与单步调试","note":"在开发者工具的 Sources 面板中，可以在代码行号上点击设置断点。当代码执行到断点时暂停，允许开发者检查此时的变量状态，并可以单步执行（Step Over, Step Into）代码，精确定位问题所在。","nextSystemPrompt":"基于设置断点与单步调试，总结出断点类型、调用堆栈查看、作用域变量监视、条件断点、异常断点等子知识点。","color":"#45B39D","expand":true,"richText":false,"isActive":false,"uid":"4e9d95c5-27fa-43f0-83b6-15e9b0af9ce9"},"children":[]},{"data":{"text":"常见 JavaScript 与 p5.js 错误","note":"如变量未定义（ReferenceError）、空值调用方法（TypeError）、语法错误（SyntaxError）。p5.js 特定错误，如图像/声音未加载完成就使用。熟悉常见错误信息能快速定位问题。","nextSystemPrompt":"基于常见错误，总结出错误类型识别、错误信息解读、p5.js 常见陷阱、资源加载错误等子知识点。","color":"#16A085","expand":true,"richText":false,"isActive":false,"uid":"8ae8db06-0889-43ee-a673-cc5c8133885a"},"children":[]},{"data":{"text":"try...catch 异常处理","note":"用 try...catch 语句捕获运行时可能出错的代码块。如果 try 块中的代码抛出错误，执行会立即跳转到 catch 块，从而防止程序崩溃，并可以给用户一个友好的错误提示。","nextSystemPrompt":"基于异常处理，总结出 try-catch 语法、错误对象属性、finally 块、自定义错误类型、错误恢复策略等子知识点。","color":"#138D75","expand":true,"richText":false,"isActive":false,"uid":"6d74160e-7420-4782-8ecd-f91f26de9af6"},"children":[]},{"data":{"text":"代码审查与静态分析","note":"在运行代码之前，通过仔细阅读代码来发现潜在问题，如拼写错误、逻辑错误。使用代码编辑器的语法高亮和错误提示功能。保持代码简洁和良好的格式也有助于减少错误。","nextSystemPrompt":"基于代码审查与静态分析，总结出代码规范、命名检查、逻辑流程图、同行评审、Lint 工具使用等子知识点。","color":"#117A65","expand":true,"richText":false,"isActive":false,"uid":"745df701-0a00-4a56-8058-c5fab52629ac"},"children":[]},{"data":{"text":"编写简单测试用例","note":"为游戏中的关键函数编写简单的测试代码，验证其输入和输出是否符合预期。例如，测试碰撞检测函数在特定坐标下是否返回正确结果。这有助于在修改代码后快速确认功能正常。","nextSystemPrompt":"基于编写简单测试用例，总结出单元测试概念、测试函数设计、边界条件测试、自动化测试入门等子知识点。","color":"#0E6655","expand":true,"richText":false,"isActive":false,"uid":"6dd67e96-68a6-420f-aae0-8c05822421d7"},"children":[]},{"data":{"text":"性能分析工具使用","note":"使用浏览器开发者工具的 Performance 面板录制一段游戏运行过程，分析其中哪些函数最耗时（“热点”），从而找到性能瓶颈（如复杂的碰撞检测或过多的对象绘制），并进行针对性优化。","nextSystemPrompt":"基于性能分析工具，总结出性能录制、火焰图分析、内存占用查看、帧率图表、优化建议识别等子知识点。","color":"#73C6B6","expand":true,"richText":false,"isActive":false,"uid":"9bb8202a-18e8-414d-a18b-92bf53ca151c"},"children":[]},{"data":{"text":"用户体验（UX）问题调试","note":"除了代码错误，还需调试用户体验问题。例如，控制是否灵敏、视觉反馈是否清晰、游戏难度是否合理。通过观察他人游玩或收集反馈来发现并改进这些问题。","nextSystemPrompt":"基于用户体验问题调试，总结出游戏试玩、用户反馈收集、交互逻辑检查、易用性评估、A/B测试概念等子知识点。","color":"#45B39D","expand":true,"richText":false,"isActive":false,"uid":"e36fa83d-f726-4572-a498-2edde0df8178"},"children":[]},{"data":{"text":"画布绘制问题排查","note":"当画面显示不正常时（如图像不显示、颜色错误），检查绘制顺序（后绘制的覆盖先绘制的）、坐标计算是否正确、是否忘记调用 background() 清除上一帧。使用描边等方式高亮元素边界有助于排查。","nextSystemPrompt":"基于画布绘制问题排查，总结出绘制顺序、坐标调试、透明度叠加、图像加载状态检查、画布缩放问题等子知识点。","color":"#16A085","expand":true,"richText":false,"isActive":false,"uid":"0ea42ba0-6a13-43a7-ab18-45670188a7bb"},"children":[]},{"data":{"text":"输入事件监听问题","note":"当键盘或鼠标输入无响应时，检查事件监听函数（如 keyPressed）是否正确定义、事件对象的 keyCode 或 key 属性是否正确使用、是否有其他代码阻止了事件传播。","nextSystemPrompt":"基于输入事件监听问题，总结出事件函数绑定、事件对象属性、事件冒泡、输入冲突、移动端触摸事件兼容性等子知识点。","color":"#138D75","expand":true,"richText":false,"isActive":false,"uid":"569ccfa1-7a93-4330-b3ca-0938c891529e"},"children":[]}]},{"data":{"text":"p5.js 游戏数学与物理基础","note":"数学是游戏编程的基石。向量用于描述位置、速度和方向；三角函数用于计算角度和旋转；距离公式是碰撞检测的核心。简单的物理概念，如速度、加速度，可以让游戏物体的运动更加真实。掌握这些数学和物理知识，能够大大增强对游戏世界的控制能力。","nextSystemPrompt":"基于游戏数学与物理基础，总结出向量运算、三角函数、距离公式、速度加速度、随机数噪声、插值运算、几何知识、物理概念、矩阵变换、自定义函数子知识点。","color":"#D35400","expand":true,"richText":false,"isActive":false,"uid":"7570e431-98a7-45d8-9ba7-dbcd422e65b5"},"children":[{"data":{"text":"向量（p5.Vector）运算","note":"p5.Vector 类封装了二维或三维向量的操作。向量可以表示位置、速度、加速度等。支持加法、减法、乘法（标量）、点积、叉积、归一化等运算，是处理物体运动和力的核心数学工具。","nextSystemPrompt":"基于向量运算，总结出向量创建、基本运算、向量大小与方向、归一化、点积角度计算等子知识点。","color":"#EDBB99","expand":true,"richText":false,"isActive":false,"uid":"b7b27d9f-69da-416d-9b91-6bf68014f8b6"},"children":[]},{"data":{"text":"三角函数（sin, cos, tan）应用","note":"三角函数在游戏中用途广泛。例如，根据角度和距离计算目标点的坐标（用于圆周运动或朝向某个方向移动），计算两个点之间的角度（atan2），以及实现平滑的波浪运动等效果。","nextSystemPrompt":"基于三角函数应用，总结出角度与弧度转换、正弦余弦波形、圆周运动、角度计算（atan2）、振荡器等子知识点。","color":"#E59866","expand":true,"richText":false,"isActive":false,"uid":"1631746b-d0af-4d8f-8aa1-30a9091f739d"},"children":[]},{"data":{"text":"距离公式与碰撞检测","note":"两点 (x1,y1) 和 (x2,y2) 之间的欧几里得距离公式为 sqrt((x2-x1)**2 + (y2-y1)**2)。这是圆形碰撞检测的基础（比较距离和半径之和）。曼哈顿距离等其他距离公式也有特定用途。","nextSystemPrompt":"基于距离公式与碰撞检测，总结出欧几里得距离、曼哈顿距离、圆形碰撞条件、距离优化计算、网格距离等子知识点。","color":"#DC7633","expand":true,"richText":false,"isActive":false,"uid":"6e61aea3-6995-4e83-b4b8-ff301577a273"},"children":[]},{"data":{"text":"速度、加速度与运动学","note":"速度是位置的变化率，加速度是速度的变化率。在游戏中，通过每帧将速度加到位置上实现移动，将加速度加到速度上实现加速/减速。这是模拟真实运动（如重力下落、车辆加速）的基础。","nextSystemPrompt":"基于速度加速度与运动学，总结出匀速运动、匀加速运动、速度矢量叠加、阻力模拟、运动方程等子知识点。","color":"#D35400","expand":true,"richText":false,"isActive":false,"uid":"22b9f78d-85f6-4fe4-85d3-344900ce8ea9"},"children":[]},{"data":{"text":"随机数（random）与噪声（noise）","note":"p5.js 的 random() 函数生成伪随机数，用于随机位置、随机颜色等。noise() 函数（柏林噪声）生成平滑、连续的随机值，常用于生成自然地形、云朵纹理或平滑的随机运动。","nextSystemPrompt":"基于随机数与噪声，总结出随机数范围控制、随机种子、噪声维度、噪声动画、自然现象模拟等子知识点。","color":"#BA4A00","expand":true,"richText":false,"isActive":false,"uid":"1feb5775-fd6c-49f3-84b2-63f9da4c0e6a"},"children":[]},{"data":{"text":"线性插值（lerp）与平滑过渡","note":"lerp(start, stop, amt) 函数计算两个值之间的线性插值。参数 amt 在 0 到 1 之间。常用于实现平滑的动画过渡，如让一个物体逐渐移动到目标位置，而不是瞬间跳转。","nextSystemPrompt":"基于线性插值与平滑过渡，总结出 lerp 函数原理、缓动函数（Easing）、动画曲线、阻尼效应、平滑跟随等子知识点。","color":"#A04000","expand":true,"richText":false,"isActive":false,"uid":"94f96648-4eab-4371-a1f6-5b0cdb8ca936"},"children":[]},{"data":{"text":"基础几何知识与形状判断","note":"除了距离，还需要其他几何知识。如判断一个点是否在矩形或圆形内，计算线段的交点，计算多边形的面积等。这些是复杂碰撞检测和游戏逻辑的基础。","nextSystemPrompt":"基于基础几何知识，总结出点与形状关系、线段相交算法、多边形包含检测、几何公式应用等子知识点。","color":"#EDBB99","expand":true,"richText":false,"isActive":false,"uid":"b1de7ebf-ac9a-43f7-addf-9f7fcdbad563"},"children":[]},{"data":{"text":"简单物理概念（力、动量、能量）","note":"了解基本的物理概念有助于设计更真实的游戏。力（F=ma）可以改变物体的运动状态。动量守恒可用于碰撞后的速度计算。虽然简单游戏可能不需要完全模拟，但概念理解能指导设计。","nextSystemPrompt":"基于简单物理概念，总结出力与加速度关系、动量概念、能量守恒、碰撞响应模拟、物理直觉培养等子知识点。","color":"#E59866","expand":true,"richText":false,"isActive":false,"uid":"451f1afa-0f49-44c5-b5fd-1ca33fd4f549"},"children":[]},{"data":{"text":"矩阵变换原理","note":"p5.js 的 translate, rotate, scale 背后是矩阵变换。理解齐次坐标和变换矩阵有助于更深入地掌握坐标系操作，对于实现复杂的层级动画和摄像机系统非常重要。","nextSystemPrompt":"基于矩阵变换原理，总结出变换矩阵概念、矩阵乘法、变换组合顺序、自定义变换、3D变换基础等子知识点。","color":"#DC7633","expand":true,"richText":false,"isActive":false,"uid":"6ec46de6-e29b-470b-9ba8-d85763239640"},"children":[]},{"data":{"text":"自定义数学工具函数","note":"将常用的数学计算封装成自定义函数，如计算两点距离的函数 dist(x1,y1,x2,y2)、将角度限制在 0-360 度的函数、映射数值范围的 map() 函数（p5.js 已提供）。提高代码复用性。","nextSystemPrompt":"基于自定义数学工具函数，总结出函数封装、参数设计、工具库创建、常用算法复用、代码整洁之道等子知识点。","color":"#D35400","expand":true,"richText":false,"isActive":false,"uid":"728a18ad-1c34-4ec4-893f-7bc55609f3f9"},"children":[]}]},{"data":{"text":"p5.js 游戏动画与视觉效果","note":"动画和视觉效果是提升游戏吸引力的关键。p5.js 提供了强大的工具来创建各种动画，从简单的形状移动、颜色渐变，到复杂的精灵动画和粒子特效。利用透明度、混合模式（blend mode）和滤镜可以创造出独特的视觉风格，增强游戏的表现力。","nextSystemPrompt":"基于游戏动画与视觉效果，总结出关键帧动画、颜色渐变、透明度与混合模式、滤镜效果、动态画笔、摄像机效果、灯光模拟、后期处理、全屏特效、视觉反馈子知识点。","color":"#C0392B","expand":true,"richText":false,"isActive":false,"uid":"7aa533f7-2d1a-4a1c-9bff-8ea0b82ef0d2"},"children":[{"data":{"text":"关键帧动画与补间","note":"定义动画的起始状态和结束状态（关键帧），然后计算中间帧的状态（补间）。可以使用线性插值（lerp）或更复杂的缓动函数来实现非线性的平滑动画效果。适用于UI动画、过场动画等。","nextSystemPrompt":"基于关键帧动画与补间，总结出关键帧定义、补间计算、缓动函数库、时间线控制、动画序列管理等子知识点。","color":"#F1948A","expand":true,"richText":false,"isActive":false,"uid":"e6a48377-33bf-404b-a2fa-0bd5f4fc3d4c"},"children":[]},{"data":{"text":"颜色渐变与动态色彩","note":"使用 lerpColor() 函数可以在两种颜色之间进行平滑过渡，创建渐变效果。通过动态改变物体的填充色或描边色（例如随血量减少从绿色变为红色），可以提供直观的视觉反馈。","nextSystemPrompt":"基于颜色渐变与动态色彩，总结出颜色插值、渐变生成、色彩循环、状态指示器、视觉效果联动等子知识点。","color":"#EC7063","expand":true,"richText":false,"isActive":false,"uid":"f09978a4-b481-4d49-bed6-caa3194107b1"},"children":[]},{"data":{"text":"透明度与混合模式","note":"通过设置颜色的 alpha 通道（透明度）可以创建半透明效果。blendMode() 函数可以改变形状重叠时的颜色混合方式（如 ADD, MULTIPLY, SCREEN），产生炫酷的光影和叠加特效。","nextSystemPrompt":"基于透明度与混合模式，总结出 Alpha 通道应用、混合模式效果、图层叠加、光影模拟、视觉层次等子知识点。","color":"#E74C3C","expand":true,"richText":false,"isActive":false,"uid":"8d16d5b4-08a9-47e5-baf8-5057c6aa0d63"},"children":[]},{"data":{"text":"滤镜效果应用","note":"p5.js 的 filter() 函数可以为整个画布或图像应用实时滤镜效果，如模糊（BLUR）、灰度（GRAY）、阈值（THRESHOLD）、反转（INVERT）。可以用于创建特殊的视觉风格或画面过渡。","nextSystemPrompt":"基于滤镜效果应用，总结出内置滤镜类型、滤镜参数调整、性能影响、组合滤镜、动态滤镜切换等子知识点。","color":"#CB4335","expand":true,"richText":false,"isActive":false,"uid":"20b104e0-32cd-4246-afa6-28da9bdfb05a"},"children":[]},{"data":{"text":"动态画笔与绘制效果","note":"通过自定义 draw() 函数中的绘制逻辑，可以实现动态画笔效果。例如，让笔触跟随鼠标移动并随时间淡化，或者模拟毛笔、喷枪等不同笔刷，用于创作类游戏或特效。","nextSystemPrompt":"基于动态画笔与绘制效果，总结出鼠标轨迹绘制、笔刷形状、轨迹淡化、自定义笔刷类、绘画游戏机制等子知识点。","color":"#B03A2E","expand":true,"richText":false,"isActive":false,"uid":"b86d1a95-25e9-43e4-bd54-264e47491a35"},"children":[]},{"data":{"text":"摄像机视角与移动","note":"通过变换坐标系（主要是 translate）来模拟摄像机的移动和缩放。让摄像机跟随玩家角色，从而在大于画布的游戏世界中导航。这是平台游戏和大型地图游戏的必备技术。","nextSystemPrompt":"基于摄像机视角与移动，总结出摄像机类设计、平滑跟随、边界限制、缩放控制、多图层视差滚动等子知识点。","color":"#F1948A","expand":true,"richText":false,"isActive":false,"uid":"d16c8ff4-0fdc-4dbc-8c6a-89c99546205b"},"children":[]},{"data":{"text":"简单灯光与阴影模拟","note":"虽然 p5.js 不是3D引擎，但可以用2D技巧模拟灯光效果。例如，使用径向渐变模拟点光源，根据物体与光源的距离计算亮度，或者用简单的几何投影模拟阴影，增加场景的立体感。","nextSystemPrompt":"基于简单灯光与阴影模拟，总结出渐变模拟光源、距离衰减、阴影投射算法、2D光照模型、氛围营造等子知识点。","color":"#EC7063","expand":true,"richText":false,"isActive":false,"uid":"4a12cd98-f6db-40aa-a477-53b2eec26adb"},"children":[]},{"data":{"text":"后期处理与离屏渲染","note":"对于复杂特效，可以先用 createGraphics() 创建一个离屏缓冲区（另一个画布），在上面完成渲染，然后再将缓冲区的内容绘制到主画布上，并可能应用全局滤镜。这有助于组织代码和实现全屏效果。","nextSystemPrompt":"基于后期处理与离屏渲染，总结出离屏缓冲区创建、渲染到纹理、后期处理链、性能考量、多层合成等子知识点。","color":"#E74C3C","expand":true,"richText":false,"isActive":false,"uid":"32365722-e70b-46c2-a74f-bb0d2ff71e02"},"children":[]},{"data":{"text":"全屏与分辨率切换","note":"使用 fullscreen() 函数可以实现全屏模式，提升游戏沉浸感。需要注意全屏时的分辨率适配和鼠标坐标校正。允许玩家切换全屏/窗口模式是良好的用户体验。","nextSystemPrompt":"基于全屏与分辨率切换，总结出全屏API使用、退出全屏、分辨率自适应、全屏UI调整、浏览器兼容性等子知识点。","color":"#CB4335","expand":true,"richText":false,"isActive":false,"uid":"877c594a-3e94-4758-a1a3-f80e38df467f"},"children":[]},{"data":{"text":"视觉反馈与界面动效","note":"对玩家的操作给予及时的视觉反馈。例如，按钮被点击时缩小再还原、角色受伤时闪烁、得分时弹出分数文字动画。这些细微的动效能显著提升游戏的操作感和品质。","nextSystemPrompt":"基于视觉反馈与界面动效，总结出按钮交互反馈、状态变化动画、文字动画效果、粒子反馈、用户体验微交互等子知识点。","color":"#B03A2E","expand":true,"richText":false,"isActive":false,"uid":"917627fd-93db-4ae7-b51b-efc0b4480734"},"children":[]}]},{"data":{"text":"p5.js 游戏中的数组与循环高级应用","note":"数组和循环是处理游戏中被量对象的基石。无论是管理一群敌人、一堆子弹，还是一组关卡数据，都需要高效地使用数组和循环。掌握遍历、查找、添加、删除数组元素的技巧，以及使用 for 和 while 循环的时机，对于编写简洁而强大的游戏代码至关重要。","nextSystemPrompt":"基于数组与循环高级应用，总结出数组遍历方法、元素增删技巧、多维数组、循环控制、迭代器函数、对象数组管理、算法优化、数据存储、循环动画、批量操作子知识点。","color":"#7D3C98","expand":true,"richText":false,"isActive":false,"uid":"4d795b56-ee70-40e3-a327-e886fbcbadb2"},"children":[{"data":{"text":"数组遍历方法（for, for...of, forEach）","note":"遍历数组是对其操作的基础。for 循环提供最大的控制力；for...of 循环语法更简洁，直接获取元素；array.forEach() 是函数式方法。在游戏循环中遍历敌人数组、子弹数组是常见操作。","nextSystemPrompt":"基于数组遍历方法，总结出循环语法差异、性能考虑、循环体内操作、遍历中断（break/continue）等子知识点。","color":"#C39BD3","expand":true,"richText":false,"isActive":false,"uid":"1c9b901a-3327-450c-962f-0fc523256c29"},"children":[]},{"data":{"text":"数组元素添加与删除","note":"使用 push() 向数组末尾添加元素（如生成新敌人），pop() 删除末尾元素。splice() 可以从指定位置删除或添加元素（如删除数组中间的某个敌人）。动态管理数组大小是游戏运行稳定的关键。","nextSystemPrompt":"基于数组元素添加与删除，总结出添加删除方法、索引操作、性能影响、动态数组管理、空位处理等子知识点。","color":"#AF7AC5","expand":true,"richText":false,"isActive":false,"uid":"b2b1e537-8a4b-4eb8-b708-b90d5aa900d5"},"children":[]},{"data":{"text":"多维数组应用","note":"用数组的数组来表示网格结构，如棋盘、地图瓦片（Tilemap）。例如，用一个二维数组 level[row][col] 来存储关卡中每个格子的类型（0=空地，1=墙壁）。","nextSystemPrompt":"基于多维数组应用，总结出二维数组创建、嵌套循环遍历、网格坐标映射、地图数据存储、网格游戏逻辑等子知识点。","color":"#9B59B6","expand":true,"richText":false,"isActive":false,"uid":"692233da-cc68-4d3b-9480-763c34b1d7f8"},"children":[]},{"data":{"text":"循环控制（break, continue）","note":"break 语句立即终止整个循环，常用于找到目标后提前退出遍历以节省资源。continue 语句跳过当前循环的剩余代码，直接进入下一次迭代。用于在遍历时忽略某些特定元素。","nextSystemPrompt":"基于循环控制，总结出 break/continue 使用场景、循环优化、条件跳出、逻辑控制流等子知识点。","color":"#884EA0","expand":true,"richText":false,"isActive":false,"uid":"ab7b68ab-c941-4985-8277-e4a1c9313e65"},"children":[]},{"data":{"text":"数组迭代器方法（map, filter, find）","note":"这些是函数式编程风格的数组方法。map() 创建一个新数组，其内容是对原数组元素处理后的结果。filter() 基于条件筛选元素。find() 查找第一个满足条件的元素。可以使代码更声明式。","nextSystemPrompt":"基于数组迭代器方法，总结出 map/filter/find 原理、回调函数、新数组生成、代码简洁性、性能对比等子知识点。","color":"#76448A","expand":true,"richText":false,"isActive":false,"uid":"d1ede5a9-090f-44de-a77e-ea31c71e0d80"},"children":[]},{"data":{"text":"对象数组的管理","note":"游戏中常使用对象数组，如 enemies = [{x:10, y:20}, ...]。遍历时，通过 enemy.x 访问每个敌人的属性。需要高效地更新、渲染和检测这些对象。","nextSystemPrompt":"基于对象数组的管理，总结出对象属性访问、数组方法结合、排序、查找特定对象、内存管理等子知识点。","color":"#633974","expand":true,"richText":false,"isActive":false,"uid":"724e2ed9-da6f-4ab9-a711-e5b221f6502b"},"children":[]},{"data":{"text":"循环中的算法优化","note":"当数组很大时，循环可能成为性能瓶颈。优化方法包括：减少循环内的计算量、使用更高效的算法（如空间分割减少碰撞检测次数）、在必要时才进行遍历（如敌人只在屏幕内时才更新）。","nextSystemPrompt":"基于循环中的算法优化，总结出算法复杂度、早期退出、计算缓存、遍历频率控制、性能瓶颈识别等子知识点。","color":"#C39BD3","expand":true,"richText":false,"isActive":false,"uid":"1be7c8cf-f3c7-4d08-8555-2871b34d599f"},"children":[]},{"data":{"text":"使用数组存储游戏数据","note":"数组可用于存储各种游戏数据，如关卡地图数据、对话文本、成就列表、排行榜分数。将数据与代码分离，便于修改和扩展。","nextSystemPrompt":"基于使用数组存储游戏数据，总结出数据结构设计、数据驱动设计、外部数据加载（JSON）、数据验证等子知识点。","color":"#AF7AC5","expand":true,"richText":false,"isActive":false,"uid":"07ce12fe-86b0-4e6a-bcea-8492ecf34421"},"children":[]},{"data":{"text":"循环与动画结合","note":"在 draw() 循环中，通过遍历数组并改变每个对象的属性（如位置、颜色）来创建群体动画。例如，让一群粒子各自运动，或者让一组UI元素依次出现。","nextSystemPrompt":"基于循环与动画结合，总结出逐帧更新、群体行为、动画同步与异步、循环延迟效果等子知识点。","color":"#9B59B6","expand":true,"richText":false,"isActive":false,"uid":"e1ca8301-d424-4196-961f-93d904e13bb3"},"children":[]},{"data":{"text":"批量操作与效率","note":"当需要对数组中的所有元素执行相同操作时（如重置所有敌人的状态、隐藏所有子弹），使用循环进行批量操作比手动一个个处理高效得多。体现了自动化的优势。","nextSystemPrompt":"基于批量操作与效率，总结出批量更新、批量渲染、状态重置、循环代替重复代码、代码DRY原则等子知识点。","color":"#884EA0","expand":true,"richText":false,"isActive":false,"uid":"db495ef8-1821-4943-8617-feb2edd36d1a"},"children":[]}]},{"data":{"text":"p5.js 游戏编程最佳实践与代码风格","note":"编写易于阅读、维护和扩展的代码是专业开发者的标志。最佳实践包括使用有意义的变量名、保持函数简短且功能单一、添加必要的注释、遵循一致的代码风格（缩进、空格）。良好的代码结构不仅能减少错误，也便于与他人合作和后续的修改。","nextSystemPrompt":"基于编程最佳实践与代码风格，总结出命名规范、函数设计、注释规则、代码格式、错误处理、常量使用、模块化思想、版本日志、代码复用、重构技巧子知识点。","color":"#1A5276","expand":true,"richText":false,"isActive":false,"uid":"17fd04f6-01f3-4727-9d9d-d183433d5406"},"children":[{"data":{"text":"变量与函数命名规范","note":"使用描述性的名称，如 playerScore 而非 ps。变量名通常以小写字母开头（camelCase），构造函数或类名以大写字母开头（PascalCase）。好的命名使代码自解释，减少注释需求。","nextSystemPrompt":"基于命名规范，总结出命名原则、大小写约定、缩写规则、避免保留字、意义明确性等子知识点。","color":"#5499C7","expand":true,"richText":false,"isActive":false,"uid":"ed06bca4-0927-4fbb-9c16-46341d49e4f2"},"children":[]},{"data":{"text":"函数设计与单一职责原则","note":"每个函数应该只完成一个明确的任务。例如，将移动玩家的逻辑封装在 movePlayer() 函数中，将碰撞检测封装在 checkCollisions() 函数中。这使代码更模块化、易于测试和调试。","nextSystemPrompt":"基于函数设计与单一职责，总结出函数长度控制、参数设计、返回值明确、功能隔离、高内聚低耦合等子知识点。","color":"#2980B9","expand":true,"richText":false,"isActive":false,"uid":"c6bc11ea-d9e0-4ed0-b763-57943fa385c2"},"children":[]},{"data":{"text":"注释与文档书写规则","note":"为复杂的逻辑、算法或重要的函数添加注释，解释其目的和工作原理。使用 JSDoc 风格的注释为函数说明参数和返回值。避免注释那些一目了然的代码。注释应说明“为什么”这么做，而非“做什么”。","nextSystemPrompt":"基于注释与文档书写，总结出注释类型、文档字符串、注释时机、代码即文档、维护注释等子知识点。","color":"#2471A3","expand":true,"richText":false,"isActive":false,"uid":"ac0fc799-7a2f-4009-9c3e-9547ca9f71b1"},"children":[]},{"data":{"text":"代码格式与缩进一致性","note":"保持一致的代码缩进（通常使用 2 个或 4 个空格），在操作符两边添加空格，合理使用空行分隔代码块。一致的格式大大提高了代码的可读性。可以使用编辑器的格式化功能。","nextSystemPrompt":"基于代码格式与缩进，总结出缩进风格、空格使用、换行规则、代码对齐、格式化工具等子知识点。","color":"#1F618D","expand":true,"richText":false,"isActive":false,"uid":"8ff27072-e69b-4a72-ba71-ad8ccd7ca2cb"},"children":[]},{"data":{"text":"错误处理与防御性编程","note":"预见代码可能出错的地方并妥善处理。例如，在访问数组元素前检查索引是否越界，在调用函数前检查参数是否有效。使用条件判断和 try-catch 来增强程序的鲁棒性。","nextSystemPrompt":"基于错误处理与防御性编程，总结出输入验证、边界条件检查、异常捕获、默认值设置、故障安全等子知识点。","color":"#1A5276","expand":true,"richText":false,"isActive":false,"uid":"13c47acc-a77b-4a33-8f93-236b327ffd7d"},"children":[]},{"data":{"text":"常量使用与魔法数字消除","note":"将代码中直接出现的、有特定含义的数字或字符串（魔法数字/魔法字符串）定义为常量。例如，const GRAVITY = 0.5;。这提高了代码的可读性和可维护性，修改时只需改一个地方。","nextSystemPrompt":"基于常量使用与魔法数字消除，总结出常量定义、命名规则、魔法数字危害、全局常量管理等子知识点。","color":"#154360","expand":true,"richText":false,"isActive":false,"uid":"8b7db158-bba0-4540-ad0e-9baab408f5f2"},"children":[]},{"data":{"text":"模块化思想与代码组织","note":"将游戏按功能分解成不同的模块（文件）。UI 相关功能放在 ui.js，物理模拟放在 physics.js。模块之间通过明确定义的接口进行通信，降低耦合度。","nextSystemPrompt":"基于模块化思想与代码组织，总结出模块划分原则、接口设计、依赖管理、全局变量最小化、命名空间等子知识点。","color":"#5499C7","expand":true,"richText":false,"isActive":false,"uid":"692cc4f5-5ed1-4be3-9fb2-a65abf806ac9"},"children":[]},{"data":{"text":"版本控制提交信息规范","note":"使用 Git 时，编写清晰、规范的提交信息（Commit Message）。简要描述本次提交的目的和更改内容。好的提交信息有助于追踪项目历史和协同工作。","nextSystemPrompt":"基于版本控制提交信息，总结出提交信息结构、语义化提交、更改范围描述、提交频率等子知识点。","color":"#2980B9","expand":true,"richText":false,"isActive":false,"uid":"d797a17a-dda6-475b-af1c-b09e82cd7da4"},"children":[]},{"data":{"text":"代码复用与工具函数库","note":"将通用的、可复用的代码片段提取出来，封装成工具函数或工具类。例如，创建一个通用的碰撞检测函数，或者一个数学计算工具库。避免重复造轮子。","nextSystemPrompt":"基于代码复用与工具函数库，总结出复用识别、工具函数设计、通用库创建、代码抽取、效用函数等子知识点。","color":"#2471A3","expand":true,"richText":false,"isActive":false,"uid":"523a8a49-70be-47a0-9f12-8521c344ee55"},"children":[]},{"data":{"text":"代码重构与持续改进","note":"重构是在不改变外部行为的前提下，优化代码的内部结构。定期回顾代码，识别可以改进的地方，如简化复杂逻辑、消除重复代码、提高性能。重构是持续的过程。","nextSystemPrompt":"基于代码重构与持续改进，总结出重构时机、重构方法、测试保障、技术债务、迭代开发等子知识点。","color":"#1F618D","expand":true,"richText":false,"isActive":false,"uid":"8c4d07fe-97bf-4c4c-b4aa-ff469b4eed65"},"children":[]}]}],"smmVersion":"0.14.0-fix.1"}